---
description: 
globs: 
alwaysApply: false
---
# CRUD API Examples

## Standard CRUD Controllers

Strapi provides built-in CRUD operations for every content type. Here's how to extend them:

### Basic Controller

```typescript
// src/api/product/controllers/product.ts
import { factories } from '@strapi/strapi';

export default factories.createCoreController('api::product.product');
```

### Extended Controller

```typescript
// src/api/product/controllers/product.ts
import { factories } from '@strapi/strapi';

export default factories.createCoreController('api::product.product', ({ strapi }) => ({
  // Find with custom logic
  async find(ctx) {
    // Call the default find method
    const { data, meta } = await super.find(ctx);
    
    // Some custom logic
    const sanitizedResults = data.map(item => ({
      ...item,
      extraField: 'Custom value',
    }));

    return { data: sanitizedResults, meta };
  },

  // Custom action
  async featured(ctx) {
    const featuredProducts = await strapi.entityService.findMany('api::product.product', {
      filters: { isFeatured: true },
      populate: ['product_variations', 'CoverImage'],
    });

    return this.transformResponse(featuredProducts);
  }
}));
```

## Custom API Methods

Strapi allows defining custom API endpoints through custom controllers and routes:

### Custom Controller Methods

```typescript
// src/api/auth/controllers/auth.ts
export default {
  // Login with OTP
  async login(ctx) {
    try {
      const { otp, otpToken } = ctx.request.body;

      // Validate OTP
      if (String(otp || "").length !== 6 || !otpToken?.includes(".")) {
        ctx.badRequest("otp or otpToken is invalid");
        return;
      }

      // Custom logic to verify OTP
      // ...

      // Generate JWT token
      const token = jwt.sign(
        { userId: userId },
        process.env.JWT_SECRET,
        { expiresIn: "30d" }
      );

      ctx.body = {
        message: "login successful",
        token,
      };
    } catch (err) {
      strapi.log.error(err);
      ctx.status = 500;
      ctx.body = JSON.stringify(err);
    }
  },

  // Get current user info
  async self(ctx) {
    try {
      const userInfo = await strapi.db
        .query("api::local-user-info.local-user-info")
        .findOne({
          where: {
            user: ctx.state.user?.id,
          },
        });

      ctx.body = { ...ctx.state.user, ...userInfo };
    } catch (err) {
      ctx.status = 500;
      ctx.body = { message: err.message };
    }
  }
};
```

### Custom Routes

```typescript
// src/api/auth/routes/auth.ts
export default {
  routes: [
    {
      method: "POST",
      path: "/auth/login",
      handler: "auth.login",
      config: {
        auth: false,
        policies: [],
        middlewares: [],
      },
    },
    {
      method: "GET",
      path: "/auth/self",
      handler: "auth.self",
      config: {
        auth: false,
        policies: [],
        middlewares: ["global::authentication"],
      },
    },
  ],
};
```

## Service Methods

Services provide reusable business logic:

```typescript
// src/api/product/services/product.ts
import { factories } from '@strapi/strapi';

export default factories.createCoreService('api::product.product', ({ strapi }) => ({
  // Extended find method
  async find(params) {
    // Add default sort if not specified
    const newParams = { ...params };
    if (!newParams.sort) {
      newParams.sort = { createdAt: 'desc' };
    }
    
    return await super.find(newParams);
  },
  
  // Custom service method
  async findByCategory(categoryId) {
    return await strapi.entityService.findMany('api::product.product', {
      filters: {
        product_main_category: categoryId,
      },
      populate: ['CoverImage', 'product_variations'],
    });
  },
}));
```

